// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks_storage

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
)

// AppendableFragment is an autogenerated mock type for the AppendableFragment type
type AppendableFragment struct {
	mock.Mock
}

type AppendableFragment_Expecter struct {
	mock *mock.Mock
}

func (_m *AppendableFragment) EXPECT() *AppendableFragment_Expecter {
	return &AppendableFragment_Expecter{mock: &_m.Mock}
}

// Append provides a mock function with given fields: ctx, data, entryId
func (_m *AppendableFragment) Append(ctx context.Context, data []byte, entryId int64) error {
	ret := _m.Called(ctx, data, entryId)

	if len(ret) == 0 {
		panic("no return value specified for Append")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []byte, int64) error); ok {
		r0 = rf(ctx, data, entryId)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AppendableFragment_Append_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Append'
type AppendableFragment_Append_Call struct {
	*mock.Call
}

// Append is a helper method to define mock.On call
//   - ctx context.Context
//   - data []byte
//   - entryId int64
func (_e *AppendableFragment_Expecter) Append(ctx interface{}, data interface{}, entryId interface{}) *AppendableFragment_Append_Call {
	return &AppendableFragment_Append_Call{Call: _e.mock.On("Append", ctx, data, entryId)}
}

func (_c *AppendableFragment_Append_Call) Run(run func(ctx context.Context, data []byte, entryId int64)) *AppendableFragment_Append_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]byte), args[2].(int64))
	})
	return _c
}

func (_c *AppendableFragment_Append_Call) Return(_a0 error) *AppendableFragment_Append_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *AppendableFragment_Append_Call) RunAndReturn(run func(context.Context, []byte, int64) error) *AppendableFragment_Append_Call {
	_c.Call.Return(run)
	return _c
}

// Close provides a mock function with given fields: ctx
func (_m *AppendableFragment) Close(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AppendableFragment_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type AppendableFragment_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
//   - ctx context.Context
func (_e *AppendableFragment_Expecter) Close(ctx interface{}) *AppendableFragment_Close_Call {
	return &AppendableFragment_Close_Call{Call: _e.mock.On("Close", ctx)}
}

func (_c *AppendableFragment_Close_Call) Run(run func(ctx context.Context)) *AppendableFragment_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *AppendableFragment_Close_Call) Return(_a0 error) *AppendableFragment_Close_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *AppendableFragment_Close_Call) RunAndReturn(run func(context.Context) error) *AppendableFragment_Close_Call {
	_c.Call.Return(run)
	return _c
}

// Finalize provides a mock function with given fields: ctx
func (_m *AppendableFragment) Finalize(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Finalize")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AppendableFragment_Finalize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Finalize'
type AppendableFragment_Finalize_Call struct {
	*mock.Call
}

// Finalize is a helper method to define mock.On call
//   - ctx context.Context
func (_e *AppendableFragment_Expecter) Finalize(ctx interface{}) *AppendableFragment_Finalize_Call {
	return &AppendableFragment_Finalize_Call{Call: _e.mock.On("Finalize", ctx)}
}

func (_c *AppendableFragment_Finalize_Call) Run(run func(ctx context.Context)) *AppendableFragment_Finalize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *AppendableFragment_Finalize_Call) Return(_a0 error) *AppendableFragment_Finalize_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *AppendableFragment_Finalize_Call) RunAndReturn(run func(context.Context) error) *AppendableFragment_Finalize_Call {
	_c.Call.Return(run)
	return _c
}

// Flush provides a mock function with given fields: ctx
func (_m *AppendableFragment) Flush(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Flush")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AppendableFragment_Flush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Flush'
type AppendableFragment_Flush_Call struct {
	*mock.Call
}

// Flush is a helper method to define mock.On call
//   - ctx context.Context
func (_e *AppendableFragment_Expecter) Flush(ctx interface{}) *AppendableFragment_Flush_Call {
	return &AppendableFragment_Flush_Call{Call: _e.mock.On("Flush", ctx)}
}

func (_c *AppendableFragment_Flush_Call) Run(run func(ctx context.Context)) *AppendableFragment_Flush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *AppendableFragment_Flush_Call) Return(_a0 error) *AppendableFragment_Flush_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *AppendableFragment_Flush_Call) RunAndReturn(run func(context.Context) error) *AppendableFragment_Flush_Call {
	_c.Call.Return(run)
	return _c
}

// GetEntry provides a mock function with given fields: ctx, entryId
func (_m *AppendableFragment) GetEntry(ctx context.Context, entryId int64) ([]byte, error) {
	ret := _m.Called(ctx, entryId)

	if len(ret) == 0 {
		panic("no return value specified for GetEntry")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) ([]byte, error)); ok {
		return rf(ctx, entryId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) []byte); ok {
		r0 = rf(ctx, entryId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, entryId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AppendableFragment_GetEntry_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEntry'
type AppendableFragment_GetEntry_Call struct {
	*mock.Call
}

// GetEntry is a helper method to define mock.On call
//   - ctx context.Context
//   - entryId int64
func (_e *AppendableFragment_Expecter) GetEntry(ctx interface{}, entryId interface{}) *AppendableFragment_GetEntry_Call {
	return &AppendableFragment_GetEntry_Call{Call: _e.mock.On("GetEntry", ctx, entryId)}
}

func (_c *AppendableFragment_GetEntry_Call) Run(run func(ctx context.Context, entryId int64)) *AppendableFragment_GetEntry_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *AppendableFragment_GetEntry_Call) Return(_a0 []byte, _a1 error) *AppendableFragment_GetEntry_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AppendableFragment_GetEntry_Call) RunAndReturn(run func(context.Context, int64) ([]byte, error)) *AppendableFragment_GetEntry_Call {
	_c.Call.Return(run)
	return _c
}

// GetFetchedLastEntryId provides a mock function with given fields: ctx
func (_m *AppendableFragment) GetFetchedLastEntryId(ctx context.Context) (int64, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetFetchedLastEntryId")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AppendableFragment_GetFetchedLastEntryId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFetchedLastEntryId'
type AppendableFragment_GetFetchedLastEntryId_Call struct {
	*mock.Call
}

// GetFetchedLastEntryId is a helper method to define mock.On call
//   - ctx context.Context
func (_e *AppendableFragment_Expecter) GetFetchedLastEntryId(ctx interface{}) *AppendableFragment_GetFetchedLastEntryId_Call {
	return &AppendableFragment_GetFetchedLastEntryId_Call{Call: _e.mock.On("GetFetchedLastEntryId", ctx)}
}

func (_c *AppendableFragment_GetFetchedLastEntryId_Call) Run(run func(ctx context.Context)) *AppendableFragment_GetFetchedLastEntryId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *AppendableFragment_GetFetchedLastEntryId_Call) Return(_a0 int64, _a1 error) *AppendableFragment_GetFetchedLastEntryId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AppendableFragment_GetFetchedLastEntryId_Call) RunAndReturn(run func(context.Context) (int64, error)) *AppendableFragment_GetFetchedLastEntryId_Call {
	_c.Call.Return(run)
	return _c
}

// GetFirstEntryId provides a mock function with given fields: ctx
func (_m *AppendableFragment) GetFirstEntryId(ctx context.Context) (int64, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetFirstEntryId")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AppendableFragment_GetFirstEntryId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFirstEntryId'
type AppendableFragment_GetFirstEntryId_Call struct {
	*mock.Call
}

// GetFirstEntryId is a helper method to define mock.On call
//   - ctx context.Context
func (_e *AppendableFragment_Expecter) GetFirstEntryId(ctx interface{}) *AppendableFragment_GetFirstEntryId_Call {
	return &AppendableFragment_GetFirstEntryId_Call{Call: _e.mock.On("GetFirstEntryId", ctx)}
}

func (_c *AppendableFragment_GetFirstEntryId_Call) Run(run func(ctx context.Context)) *AppendableFragment_GetFirstEntryId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *AppendableFragment_GetFirstEntryId_Call) Return(_a0 int64, _a1 error) *AppendableFragment_GetFirstEntryId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AppendableFragment_GetFirstEntryId_Call) RunAndReturn(run func(context.Context) (int64, error)) *AppendableFragment_GetFirstEntryId_Call {
	_c.Call.Return(run)
	return _c
}

// GetFragmentId provides a mock function with no fields
func (_m *AppendableFragment) GetFragmentId() int64 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetFragmentId")
	}

	var r0 int64
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// AppendableFragment_GetFragmentId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFragmentId'
type AppendableFragment_GetFragmentId_Call struct {
	*mock.Call
}

// GetFragmentId is a helper method to define mock.On call
func (_e *AppendableFragment_Expecter) GetFragmentId() *AppendableFragment_GetFragmentId_Call {
	return &AppendableFragment_GetFragmentId_Call{Call: _e.mock.On("GetFragmentId")}
}

func (_c *AppendableFragment_GetFragmentId_Call) Run(run func()) *AppendableFragment_GetFragmentId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *AppendableFragment_GetFragmentId_Call) Return(_a0 int64) *AppendableFragment_GetFragmentId_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *AppendableFragment_GetFragmentId_Call) RunAndReturn(run func() int64) *AppendableFragment_GetFragmentId_Call {
	_c.Call.Return(run)
	return _c
}

// GetFragmentKey provides a mock function with no fields
func (_m *AppendableFragment) GetFragmentKey() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetFragmentKey")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// AppendableFragment_GetFragmentKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFragmentKey'
type AppendableFragment_GetFragmentKey_Call struct {
	*mock.Call
}

// GetFragmentKey is a helper method to define mock.On call
func (_e *AppendableFragment_Expecter) GetFragmentKey() *AppendableFragment_GetFragmentKey_Call {
	return &AppendableFragment_GetFragmentKey_Call{Call: _e.mock.On("GetFragmentKey")}
}

func (_c *AppendableFragment_GetFragmentKey_Call) Run(run func()) *AppendableFragment_GetFragmentKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *AppendableFragment_GetFragmentKey_Call) Return(_a0 string) *AppendableFragment_GetFragmentKey_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *AppendableFragment_GetFragmentKey_Call) RunAndReturn(run func() string) *AppendableFragment_GetFragmentKey_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastEntryId provides a mock function with given fields: ctx
func (_m *AppendableFragment) GetLastEntryId(ctx context.Context) (int64, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetLastEntryId")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AppendableFragment_GetLastEntryId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastEntryId'
type AppendableFragment_GetLastEntryId_Call struct {
	*mock.Call
}

// GetLastEntryId is a helper method to define mock.On call
//   - ctx context.Context
func (_e *AppendableFragment_Expecter) GetLastEntryId(ctx interface{}) *AppendableFragment_GetLastEntryId_Call {
	return &AppendableFragment_GetLastEntryId_Call{Call: _e.mock.On("GetLastEntryId", ctx)}
}

func (_c *AppendableFragment_GetLastEntryId_Call) Run(run func(ctx context.Context)) *AppendableFragment_GetLastEntryId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *AppendableFragment_GetLastEntryId_Call) Return(_a0 int64, _a1 error) *AppendableFragment_GetLastEntryId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AppendableFragment_GetLastEntryId_Call) RunAndReturn(run func(context.Context) (int64, error)) *AppendableFragment_GetLastEntryId_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastModified provides a mock function with given fields: ctx
func (_m *AppendableFragment) GetLastModified(ctx context.Context) int64 {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetLastModified")
	}

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// AppendableFragment_GetLastModified_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastModified'
type AppendableFragment_GetLastModified_Call struct {
	*mock.Call
}

// GetLastModified is a helper method to define mock.On call
//   - ctx context.Context
func (_e *AppendableFragment_Expecter) GetLastModified(ctx interface{}) *AppendableFragment_GetLastModified_Call {
	return &AppendableFragment_GetLastModified_Call{Call: _e.mock.On("GetLastModified", ctx)}
}

func (_c *AppendableFragment_GetLastModified_Call) Run(run func(ctx context.Context)) *AppendableFragment_GetLastModified_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *AppendableFragment_GetLastModified_Call) Return(_a0 int64) *AppendableFragment_GetLastModified_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *AppendableFragment_GetLastModified_Call) RunAndReturn(run func(context.Context) int64) *AppendableFragment_GetLastModified_Call {
	_c.Call.Return(run)
	return _c
}

// GetLogId provides a mock function with no fields
func (_m *AppendableFragment) GetLogId() int64 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetLogId")
	}

	var r0 int64
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// AppendableFragment_GetLogId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLogId'
type AppendableFragment_GetLogId_Call struct {
	*mock.Call
}

// GetLogId is a helper method to define mock.On call
func (_e *AppendableFragment_Expecter) GetLogId() *AppendableFragment_GetLogId_Call {
	return &AppendableFragment_GetLogId_Call{Call: _e.mock.On("GetLogId")}
}

func (_c *AppendableFragment_GetLogId_Call) Run(run func()) *AppendableFragment_GetLogId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *AppendableFragment_GetLogId_Call) Return(_a0 int64) *AppendableFragment_GetLogId_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *AppendableFragment_GetLogId_Call) RunAndReturn(run func() int64) *AppendableFragment_GetLogId_Call {
	_c.Call.Return(run)
	return _c
}

// GetRawBufSize provides a mock function with no fields
func (_m *AppendableFragment) GetRawBufSize() int64 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetRawBufSize")
	}

	var r0 int64
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// AppendableFragment_GetRawBufSize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRawBufSize'
type AppendableFragment_GetRawBufSize_Call struct {
	*mock.Call
}

// GetRawBufSize is a helper method to define mock.On call
func (_e *AppendableFragment_Expecter) GetRawBufSize() *AppendableFragment_GetRawBufSize_Call {
	return &AppendableFragment_GetRawBufSize_Call{Call: _e.mock.On("GetRawBufSize")}
}

func (_c *AppendableFragment_GetRawBufSize_Call) Run(run func()) *AppendableFragment_GetRawBufSize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *AppendableFragment_GetRawBufSize_Call) Return(_a0 int64) *AppendableFragment_GetRawBufSize_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *AppendableFragment_GetRawBufSize_Call) RunAndReturn(run func() int64) *AppendableFragment_GetRawBufSize_Call {
	_c.Call.Return(run)
	return _c
}

// GetSegmentId provides a mock function with no fields
func (_m *AppendableFragment) GetSegmentId() int64 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetSegmentId")
	}

	var r0 int64
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// AppendableFragment_GetSegmentId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSegmentId'
type AppendableFragment_GetSegmentId_Call struct {
	*mock.Call
}

// GetSegmentId is a helper method to define mock.On call
func (_e *AppendableFragment_Expecter) GetSegmentId() *AppendableFragment_GetSegmentId_Call {
	return &AppendableFragment_GetSegmentId_Call{Call: _e.mock.On("GetSegmentId")}
}

func (_c *AppendableFragment_GetSegmentId_Call) Run(run func()) *AppendableFragment_GetSegmentId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *AppendableFragment_GetSegmentId_Call) Return(_a0 int64) *AppendableFragment_GetSegmentId_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *AppendableFragment_GetSegmentId_Call) RunAndReturn(run func() int64) *AppendableFragment_GetSegmentId_Call {
	_c.Call.Return(run)
	return _c
}

// GetSize provides a mock function with no fields
func (_m *AppendableFragment) GetSize() int64 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetSize")
	}

	var r0 int64
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// AppendableFragment_GetSize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSize'
type AppendableFragment_GetSize_Call struct {
	*mock.Call
}

// GetSize is a helper method to define mock.On call
func (_e *AppendableFragment_Expecter) GetSize() *AppendableFragment_GetSize_Call {
	return &AppendableFragment_GetSize_Call{Call: _e.mock.On("GetSize")}
}

func (_c *AppendableFragment_GetSize_Call) Run(run func()) *AppendableFragment_GetSize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *AppendableFragment_GetSize_Call) Return(_a0 int64) *AppendableFragment_GetSize_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *AppendableFragment_GetSize_Call) RunAndReturn(run func() int64) *AppendableFragment_GetSize_Call {
	_c.Call.Return(run)
	return _c
}

// IsClosed provides a mock function with given fields: ctx
func (_m *AppendableFragment) IsClosed(ctx context.Context) bool {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for IsClosed")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context) bool); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// AppendableFragment_IsClosed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsClosed'
type AppendableFragment_IsClosed_Call struct {
	*mock.Call
}

// IsClosed is a helper method to define mock.On call
//   - ctx context.Context
func (_e *AppendableFragment_Expecter) IsClosed(ctx interface{}) *AppendableFragment_IsClosed_Call {
	return &AppendableFragment_IsClosed_Call{Call: _e.mock.On("IsClosed", ctx)}
}

func (_c *AppendableFragment_IsClosed_Call) Run(run func(ctx context.Context)) *AppendableFragment_IsClosed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *AppendableFragment_IsClosed_Call) Return(_a0 bool) *AppendableFragment_IsClosed_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *AppendableFragment_IsClosed_Call) RunAndReturn(run func(context.Context) bool) *AppendableFragment_IsClosed_Call {
	_c.Call.Return(run)
	return _c
}

// IsFull provides a mock function with given fields: ctx, requestSize
func (_m *AppendableFragment) IsFull(ctx context.Context, requestSize int64) bool {
	ret := _m.Called(ctx, requestSize)

	if len(ret) == 0 {
		panic("no return value specified for IsFull")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, int64) bool); ok {
		r0 = rf(ctx, requestSize)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// AppendableFragment_IsFull_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsFull'
type AppendableFragment_IsFull_Call struct {
	*mock.Call
}

// IsFull is a helper method to define mock.On call
//   - ctx context.Context
//   - requestSize int64
func (_e *AppendableFragment_Expecter) IsFull(ctx interface{}, requestSize interface{}) *AppendableFragment_IsFull_Call {
	return &AppendableFragment_IsFull_Call{Call: _e.mock.On("IsFull", ctx, requestSize)}
}

func (_c *AppendableFragment_IsFull_Call) Run(run func(ctx context.Context, requestSize int64)) *AppendableFragment_IsFull_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *AppendableFragment_IsFull_Call) Return(_a0 bool) *AppendableFragment_IsFull_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *AppendableFragment_IsFull_Call) RunAndReturn(run func(context.Context, int64) bool) *AppendableFragment_IsFull_Call {
	_c.Call.Return(run)
	return _c
}

// IsGrowing provides a mock function with given fields: ctx
func (_m *AppendableFragment) IsGrowing(ctx context.Context) (bool, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for IsGrowing")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (bool, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) bool); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AppendableFragment_IsGrowing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsGrowing'
type AppendableFragment_IsGrowing_Call struct {
	*mock.Call
}

// IsGrowing is a helper method to define mock.On call
//   - ctx context.Context
func (_e *AppendableFragment_Expecter) IsGrowing(ctx interface{}) *AppendableFragment_IsGrowing_Call {
	return &AppendableFragment_IsGrowing_Call{Call: _e.mock.On("IsGrowing", ctx)}
}

func (_c *AppendableFragment_IsGrowing_Call) Run(run func(ctx context.Context)) *AppendableFragment_IsGrowing_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *AppendableFragment_IsGrowing_Call) Return(_a0 bool, _a1 error) *AppendableFragment_IsGrowing_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AppendableFragment_IsGrowing_Call) RunAndReturn(run func(context.Context) (bool, error)) *AppendableFragment_IsGrowing_Call {
	_c.Call.Return(run)
	return _c
}

// Load provides a mock function with given fields: ctx
func (_m *AppendableFragment) Load(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Load")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AppendableFragment_Load_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Load'
type AppendableFragment_Load_Call struct {
	*mock.Call
}

// Load is a helper method to define mock.On call
//   - ctx context.Context
func (_e *AppendableFragment_Expecter) Load(ctx interface{}) *AppendableFragment_Load_Call {
	return &AppendableFragment_Load_Call{Call: _e.mock.On("Load", ctx)}
}

func (_c *AppendableFragment_Load_Call) Run(run func(ctx context.Context)) *AppendableFragment_Load_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *AppendableFragment_Load_Call) Return(_a0 error) *AppendableFragment_Load_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *AppendableFragment_Load_Call) RunAndReturn(run func(context.Context) error) *AppendableFragment_Load_Call {
	_c.Call.Return(run)
	return _c
}

// Release provides a mock function with given fields: ctx
func (_m *AppendableFragment) Release(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Release")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AppendableFragment_Release_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Release'
type AppendableFragment_Release_Call struct {
	*mock.Call
}

// Release is a helper method to define mock.On call
//   - ctx context.Context
func (_e *AppendableFragment_Expecter) Release(ctx interface{}) *AppendableFragment_Release_Call {
	return &AppendableFragment_Release_Call{Call: _e.mock.On("Release", ctx)}
}

func (_c *AppendableFragment_Release_Call) Run(run func(ctx context.Context)) *AppendableFragment_Release_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *AppendableFragment_Release_Call) Return(_a0 error) *AppendableFragment_Release_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *AppendableFragment_Release_Call) RunAndReturn(run func(context.Context) error) *AppendableFragment_Release_Call {
	_c.Call.Return(run)
	return _c
}

// NewAppendableFragment creates a new instance of AppendableFragment. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewAppendableFragment(t interface {
	mock.TestingT
	Cleanup(func())
}) *AppendableFragment {
	mock := &AppendableFragment{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
