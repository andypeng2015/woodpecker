# 本地文件系统存储设计

## 1. 概述

本地文件系统存储实现了一个基于磁盘的日志存储系统，使用内存映射(mmap)来提供高效的读写性能。虽然本地文件系统支持append操作，但为了保持与对象存储实现的一致性，我们仍然保留了Fragment的概念。

## 2. 核心组件

### 2.1 FragmentFile

FragmentFile是基本的存储单元，负责单个日志片段文件的读写操作。

#### 文件布局
```
[文件头(4K)] + [数据区域(向前增长)] + [...空闲区域...] + [索引区域(向后增长)] + [Footer(固定大小)]
```

- **文件头(4K)**: 存储magic string和版本信息
- **数据区域**: 存储实际的日志条目，从4K位置开始向后增长
- **空闲区域**: 数据区域和索引区域之间的未使用空间
- **索引区域**: 存储每个条目的偏移量，从文件末尾向前增长
- **Footer**: 存储元数据信息

#### 数据条目格式
```
[Payload大小(4字节)] + [CRC(4字节)] + [实际数据(变长)]
```

### 2.2 DiskLogFile

DiskLogFile管理多个Fragment文件，提供统一的读写接口。

#### 目录结构
```
/basePath/
  └── log_[logID]/
      ├── fragment_[startOffset1]
      ├── fragment_[startOffset2]
      └── ...
```

## 3. 关键设计决策

### 3.1 使用mmap的原因
- 提供零拷贝的读写操作
- 支持随机访问
- 操作系统自动处理页面缓存
- 提供内存级别的读写性能

### 3.2 Fragment的必要性
虽然本地文件系统支持append，但保留Fragment概念带来以下好处：
- 保持与对象存储实现相同的架构
- 便于实现文件大小限制
- 支持分段管理和清理
- 简化并发控制
- 提高系统恢复能力

### 3.3 空间管理
- 预分配固定大小的文件空间
- 数据区域和索引区域分别从两端增长
- 当两个区域相遇时创建新的Fragment
- 通过精确的空间计算避免溢出

## 4. 性能考虑

### 4.1 写入性能优化
- 使用mmap实现零拷贝写入
- 批量写入减少系统调用
- 异步写入支持
- 预分配空间减少扩容开销

### 4.2 读取性能优化
- 通过索引实现快速定位
- 支持随机读取
- 利用操作系统页面缓存
- 支持范围读取

### 4.3 内存使用
- 通过mmap实现按需加载
- 控制单个Fragment大小
- 实现内存使用限制
- 支持内存映射解除

## 5. 可靠性保证

### 5.1 数据完整性
- 使用CRC32校验数据
- 文件头包含magic string验证
- 索引区域和数据区域分离
- 支持数据恢复

### 5.2 并发控制
- 使用读写锁保护共享资源
- 支持多读单写模式
- 原子操作保证计数器
- 文件锁防止并发写入

## 6. 配置参数

### 6.1 Fragment配置
- 文件大小限制
- 最大条目数
- 预分配空间大小
- 内存映射选项

### 6.2 LogFile配置
- 基础路径
- Fragment大小
- 异步写入缓冲区大小
- 清理策略

## 7. 使用示例

```go
// 创建LogFile
logFile, err := NewDiskLogFile(1, "/path/to/logs", WithFragmentSize(4*1024*1024))

// 写入数据
err = logFile.Append(ctx, []byte("log entry"))

// 异步写入
entryID, resultCh, err := logFile.AppendAsync(ctx, 0, []byte("async log entry"))

// 读取数据
reader, err := logFile.NewReader(ctx, storage.ReaderOpt{
    StartSequenceNum: 0,
    EndSequenceNum:   100,
})
```

## 8. 注意事项

1. 确保足够的磁盘空间
2. 定期清理旧的Fragment文件
3. 监控内存使用情况
4. 处理文件系统错误
5. 实现优雅关闭
6. 考虑系统崩溃恢复
